-------------------------------------------
-- ■■■ Contents (chp-90)
-------------------------------------------
--■■■  P-7	Select절-기본명령어
--■■■  P-8	Select절-기타
--■■■  P-9	Select절-Distinct
--■■■  P-10	Select절-Distinct vs Union
--■■■  P-11	Select절-연결연산자 (Concat)
--■■■  P-13	From절
--■■■  P-16	Where절-= (Equal)
--■■■  P-17	Where절-NOT =, ^=, !=
--■■■  P-18	Where절-<=, >=
--■■■  P-19	Where절-< , >
--■■■  P-20	Where절-< , > (날짜)
--■■■  P-21	※문자비교
--■■■  P-24	Where절-Between
--■■■  P-25	Where절-IN
--■■■  P-26	Where절-LIKE
--■■■  P-27	※Between vs (Union)Intersect
--■■■  P-28	※IN vs Union
--■■■  P-30	Where절-AND
--■■■  P-31	Where절-AND vs 연결연산자 "Pipe"
--■■■  P-33	Where절-OR
--■■■  P-35	Union vs Union ALL
--■■■  P-36	(Union) Intersect
--■■■  P-37	(Union) Minus
--■■■  P-38	※Union=Union ALL
--■■■  P-40	Where절-^=, !=, <>
--■■■  P-41	Where절-NOT Between (Union)
--■■■  P-42	Where절-NOT IN ( Intersect )
--■■■  P-43	Where절-NOT IN
--■■■  P-44	Where절-NOT LIKE
--■■■  P-46	연산자 우선 순위
--■■■  P-48	NULL 정의 및 속성 확인
--■■■  P-49	NULL 생성 및 조회,식별
--■■■  P-50	NULL 연산-불가능
--■■■  P-51	NULL 연산-불가능을 NVL활용, 가능하게...
--■■■  P-53	rder by-ASC
--■■■  P-54	Order by-DESC
--■■■  P-55	Order by-Alias, Column Number 정렬
--■■■  P-56	Order by-날짜, 문자 정렬
--■■■  P-57	Order by-복수컬럼 정렬
--■■■  P-58	Order by-Null 정렬
--■■■  P-59	Order by-NVL 정렬
--■■■  P-60	Order by-NULLS 정렬
--■■■  P-63	문자함수-SubStr
--■■■  P-64	문자함수-Replace
--■■■  P-65	※Replace vs Update
--■■■  P-66	문자함수-TRIM
--■■■  P-67	문자함수-UPPER
--■■■  P-68	문자함수-lower
--■■■  P-69	문자함수-Length
--■■■  P-70	문자함수-vSize
--■■■  P-71	문자함수-LPAD
--■■■  P-72	문자함수-RPAD
--■■■  P-73	문자함수-INITCAP
--■■■  P-74	※함수응용-Data Masking(주민번호 처리사례)
--■■■  P-75	※함수응용-Data Masking(주민번호 처리사례)
--■■■  P-76	※함수응용-Data Masking(주민번호 처리사례)
--■■■  P-77	※함수응용-Data Masking(주민번호 처리사례)
--■■■  P-80	숫자함수-ROUND(절상)
--■■■  P-81	숫자함수-TRUNC(절삭)
--■■■  P-82	숫자함수-CEIL(강제절상) , FLOOR(강제절삭)
--■■■  P-85	날짜함수-Sysdate
--■■■  P-86	날짜함수-Trunc, Round
--■■■  P-87	※ROUND vs TRUNC
--■■■  P-88	날짜함수-ADD_MONTHS
--■■■  P-91	변환함수-TO_CHAR
--■■■  P-92	변환함수-TO_DATE(YYYY-MM-DD)
--■■■  P-93	변환함수-TO_DATE(YY-MM-DD)
--■■■  P-94	변환함수-TO_NUMBER
--■■■  P-96	변환함수-NVL, NVL2 (숫자형으로)
--■■■  P-97	변환함수-NVL, NVL2 (문자형으로)
--■■■  P-99	변환함수-DeCode함수
--■■■  P-102	※DeCode함수-응용(가로출력)
--■■■  P-104	CASE구문
--■■■  P-105	CASE구문-비교연산자
--■■■  P-106	CASE구문-Between
--■■■  P-107	CASE구문-IN
--■■■  P-110	*, Order by
--■■■  P-111	Count, Sum
--■■■  P-112	Where, 집계함수, 비교 & 산술연산자
--■■■  P-113	Distinct
--■■■  P-114	Group by
--■■■  P-115	NVL
--■■■  P-116	Round, Order by
--■■■  P-117	Having-InLineView, RowNum
--■■■  P-119	Decode 함수, Case 구문
--■■■  P-121	Scalar SubQuery vs INNER JOIN
--■■■  P-122	Outer Join vs Inner Join
--■■■  P-123	Scalar SubQuery vs Outer Join
--■■■  P-125	Inner Join (Oracle vs ANSI)
--■■■  P-126	Outer Join (Oracle vs ANSI)

-------------------------------------------
-- ■■■  P-7	Select절-기본명령어
-------------------------------------------

-- * 사용
Select *
From  EMPLOYEES
;


-- 컬럼명 사용 ( ※참고 컬럼명 찾기)
Select employee_id, first_name
From  EMPLOYEES
;


-- Distinct 사용
Select DISTINCT Job_ID , Manager_ID
From  EMPLOYEES
;


--(사칙)연산자 가지사례
Select salary,salary * 100 From employees
;

Select salary,salary / 100 From employees
;

Select salary,salary + 100 From employees
;

Select salary,salary - 100 From employees
;

Select salary,salary * 100 ,salary / 100 ,salary + 100 ,salary - 100 From employees
;


-- 함수 사용 ( ※참고 컬럼명 찾기)
Select employee_id ,SYSDATE ,hire_date ,ROUND(sysdate-hire_date) as WorkDay
From  EMPLOYEES
;


-- Pipe (연결연산자) 사용
Select employee_id , SYSDATE ||  hire_date From  EMPLOYEES
;

Select employee_id , SYSDATE || '/' || hire_date From  EMPLOYEES
;

Select employee_id , SYSDATE || ' / ' || hire_date as 날짜비교 From  EMPLOYEES
;


※참고 컬럼명 찾기1 (Oracle )
DESC EMPLOYEES ; 

※참고 컬럼명 찾기2 (대문자에 주의)
SELECT COLUMN_NAME
FROM  ALL_TAB_COLUMNS 
WHERE table_name = 'EMPLOYEES'
    AND owner       = 'SCOTT' 
;

-------------------------------------------
-- ■■■  P-8	Select절-기타
-------------------------------------------

--SQL절 명령어-기타
Select 1, 'x' From Employees
;

Select employee_id
      ,SYSDATE || '/‘ || hire_date as "날짜비교"
From   EMPLOYEES
;

Select job_id, /* Manager_ID */
From Employees
;

Select /*+First_Rows(10)*/ job_id, Manager_ID
From Employees
;

-------------------------------------------
-- ■■■  P-9	Select절-Distinct
-------------------------------------------

-- 107건 전체 조회
Select job_id
From  employees
;


--Distinct 19건 조회
Select Distinct  job_id
From  employees
;

-------------------------------------------
-- ■■■  P-10	Select절-Distinct vs Union
-------------------------------------------

--Union
Select job_id
From  employees
UNION
Select job_id
From  employees
;


--※ 비교 Disintct
Select Distinct  job_id
From  employees
;


--※ 비교 Union ALL
Select job_id
From  employees
UNION ALL
Select job_id
From  employees
;

-------------------------------------------
-- ■■■  P-11	Select절-연결연산자 (Concat)
-------------------------------------------

-- 연결연산자 및 Alias사용
Select last_name || salary AS "이름 월급"
From  employees
;


--연결 함수 CONCAT 사용
Select concat(last_name , salary)  as "이름 월급"
From  employees
;


-- 가상컬럼(문자열), 연결연산자 및 Alias사용
Select    '사원 '        ||  last_name ||
             '의 급여는 ' || salary ||
             ' 입니다.'
             as  "사원 / 지급내역"
From  employees
;

-------------------------------------------
-- ■■■  P-13	From절
-------------------------------------------

--From절 사용예
Select E.JOB_ID, E.MANAGER_ID From EMPLOYEES E
;

Select * From  (Select E.JOB_ID, E.MANAGER_ID From EMPLOYEES E)
;

Select * From SALES_ORDER_PART PARTITION(PR_2002_01)  E
;


--DB Link
Select * From all_db_links
;

Select *
From    SALES_ORDER_PART@LINKENAME E
;

-------------------------------------------
-- ■■■  P-16	Where절-= (Equal)
-------------------------------------------

-- 문자열 'King' 데이터 조회 (대문자 입력)
Select employee_id,last_name,job_id, salary
From employees
Where last_name = 'KING'
;


-- 문자열 'King' 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where last_name = 'King'
;


-- 문자열 'SALES' 데이터 조회 (소문자 입력)
Select DeptNO, DName, Loc
From DEPT
Where DName = 'sales'
;


-- 문자열 'SALES' 데이터 조회
Select DeptNO, DName, Loc
From DEPT
Where DName = 'SALES'
;

-------------------------------------------
-- ■■■  P-17	Where절-NOT =, ^=, !=
-------------------------------------------

-- 부정 연산자 <> 사용예
Select DeptNO, DName, Loc
From DEPT
Where DName <> 'SALES'
;


-- 부정 연산자 ^= 사용예
Select DeptNO, DName, Loc
From DEPT
Where DName ^= 'SALES'
;


-- 부정 연산자 != 사용예
Select DeptNO, DName, Loc
From DEPT
Where DName != 'SALES'
;


-- 논리 부정 NOT 사용예
Select DeptNO, DName, Loc
From DEPT
Where NOT DName = 'SALES‘
;

-------------------------------------------
-- ■■■  P-18	Where절-<=, >=
-------------------------------------------

--숫자 10,000 "이상" 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where salary >= 10000
;


--숫자 10,000 "이하" 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where salary <= 10000
;

-------------------------------------------
-- ■■■  P-19	Where절-< , >
-------------------------------------------

--숫자 10,000 "보다 큰" 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where salary > 10000
;


--숫자 10,000 "보다 작은" 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where salary < 10000
;

-------------------------------------------
-- ■■■  P-20	Where절-< , > (날짜)
-------------------------------------------

--날짜의 크다라는 의미는 "현재시간"에 가까움
Select employee_id,last_name,salary,hire_date
From employees
Where hire_date > '2007-12-17'
;


--작다의 의미는 "과거의 시간"을 의미
Select employee_id,last_name,salary,hire_date
From employees
Where hire_date < '2003-06-30'
;

-------------------------------------------
-- ■■■  P-21	※문자비교
-------------------------------------------

-- 문자 T  "보다 큰" 데이터 조회 (ASCII T Code =84)
Select employee_id,last_name,job_id, salary
From employees
Where LAST_NAME > 'T'
;


--주) ASCII 찾는 쿼리 : Select ascii('T') From dual
;


-- 문자 C  "보다 작은" 데이터 조회
Select employee_id,last_name,job_id, salary
From employees
Where LAST_NAME < 'C'
;

-------------------------------------------
-- ■■■  P-24	Where절-Between
-------------------------------------------

--Between 9000 ~ 10000
Select employee_id,last_name ,job_id, salary
From employees
Where salary BETWEEN 9000 AND 10000
;


--Between 이용한 10000 ~ 9000
Select employee_id,last_name ,job_id, salary
From employees
Where salary  BETWEEN 10000 AND 9000
;


--비교연산자 9000 ~ 10000
Select employee_id,last_name ,job_id, salary
From employees
Where salary >= 9000 AND salary <= 10000
;


--비교연산자 10000 ~ 9000
Select employee_id,last_name ,job_id, salary
From employees
Where salary <= 10000 AND salary >= 9000
;

-------------------------------------------
-- ■■■  P-25	Where절-IN
-------------------------------------------

-- IN조건(문자)
Select employee_id,last_name,salary,hire_date
From employees
Where last_name IN ( 'King','Abel','Jones')
;


-- NLS_Date_Format 조회
Select  *
From NLS_SESSION_PARAMETERS
Where parameter = 'NLS_DATE_FORMAT'
;


-- NLS_Date_Format 변경
Alter session set nls_date_format='YYYY/MM/DD HH24:MI:SS'
;


-- IN조건(날짜/시간)
Select employee_id,last_name,salary,hire_date
From employees
Where hire_date IN ( '2001/01/13','2007/02/07')
;

-------------------------------------------
-- ■■■  P-26	Where절-LIKE
-------------------------------------------

-- J뒤 1개문자 매칭
Select employee_id,last_name,salary
From employees
Where last_name LIKE  'J_'
;

Select employee_id,last_name,salary
From employees
Where last_name LIKE  'J_%'
;


--J뒤의 4개 문자 매칭으로 2~5 조회
Select employee_id,last_name,salary
From employees
Where last_name LIKE  'J____'
;


--J뒤에 %를 통한 문자열 매칭, 결과추출
Select employee_id,last_name,salary
From employees
Where last_name LIKE  'J%'
;

Select employee_id,last_name,salary
From employees
Where last_name LIKE  '%J%'
;

-------------------------------------------
-- ■■■  P-27	※Between vs (Union)Intersect
-------------------------------------------

--between
Select employee_id,last_name ,job_id, salary From employees
Where salary  BETWEEN 9000 AND 10000
;


--비교연산자
Select employee_id,last_name ,job_id, salary From employees
Where SALARY >= 9000 AND SALARY <= 10000
;


--(union) Intersect
Select employee_id,last_name ,job_id, salary From employees
Where SALARY >= 9000
INTERSECT
Select employee_id,last_name ,job_id, salary  From employees
Where SALARY <= 10000
;

-------------------------------------------
-- ■■■  P-28	※IN vs Union
-------------------------------------------

-- 1. IN조건(숫자)
Select employee_id
          ,last_name
From employees
Where
employee_id IN (100,200,206)
;


--2. OR로 작성
Select employee_id
        ,last_name
From employees
Where employee_id=100
      OR employee_id=200
      OR employee_id=206
;


--3. Union으로 작성
Select employee_id
        ,last_name
From employees
Where employee_id =  100
UNION
Select employee_id
          ,last_name
From employees
Where employee_id =  200
UNION
Select employee_id
          ,last_name
From employees
Where  employee_id = 206
;


--4. Union ALLL로 작성
Select employee_id
        ,last_name
From employees
Where employee_id =  100
UNION ALL
Select employee_id
          ,last_name
From employees
Where employee_id =  200
UNION ALL
Select employee_id
          ,last_name
From employees
Where  employee_id = 206
;


--A. IN조건(숫자)
Select Department_ID
From employees
Where
Department_ID IN (10,90,110 )
;


--B. OR로 작성
Select Department_ID
From employees
Where
    Department_ID = 10
OR Department_ID = 90
OR Department_ID = 110
;


--C. Union으로 작성
Select Department_ID
From employees
Where
Department_ID = 10
UNION
Select Department_ID
From employees
Where  Department_ID = 90
UNION
Select Department_ID
From employees
Where  Department_ID= 110
;


--D. Union ALL로 작성
Select Department_ID
From employees
Where
Department_ID = 10
UNION ALL
Select Department_ID
From employees
Where  Department_ID = 90
UNION ALL
Select Department_ID
From employees
Where  Department_ID= 110
;

-------------------------------------------
-- ■■■  P-30	Where절-AND
-------------------------------------------

-- between 에서 AND 사용 사례
Select  employee_id,last_name
          , job_id, salary
From employees
Where salary Between 9000 AND 10000
;


-- 비교연사자 에서 AND 사용 사례
Select employee_id,last_name,job_id,salary
From employees
Where salary >= 9000
    AND salary <= 10000
;


-- 3개 이상의 AND 및 비교 연산자 사용
Select employee_id,last_name,job_id,salary
From employees
Where 1 = 1
AND  job_id       =   'IT_PROG'
AND  salary       >=  5000
AND  last_name like  'H%'
;

-------------------------------------------
-- ■■■  P-31	Where절-AND vs 연결연산자 "Pipe"
-------------------------------------------

--Where 절에 AND 사용 결과
Select employee_id,last_name ,job_id, salary
From employees
Where job_id = 'IT_PROG' AND salary = 9000
;


--Where 절에  || 사용 결과
Select employee_id,last_name ,job_id, salary
From employees
Where job_id || salary =  'IT_PROG' || 9000
;


-- ※ Select절과 Where절 모두에 || 사용
Select employee_id || last_name  || ,job_id, salary
From employees
Where job_id || salary =  'IT_PROG' || 9000
;

-------------------------------------------
-- ■■■  P-33	Where절-OR
-------------------------------------------

--Job_id가 IT*  인것
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'

--Salary가 6000인것
Select employee_id,last_name
          ,job_id, salary
From employees
Where salary=6000
;


-- OR 연산자로 조회
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
      OR salary=6000
;


--Union 으로 동일 결과 추출
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
UNION
Select employee_id,last_name
          ,job_id, salary
From employees
Where salary=6000
;

-------------------------------------------
-- ■■■  P-35	Union vs Union ALL
-------------------------------------------

--Union
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id like 'it_%'
UNION
Select employee_id,last_name
          ,job_id, salary
From employees
Where salary=6000
;


--Union ALL
Select  employee_id , last_name , job_id , salary
From   employees
Where  job_id like 'it_%'
UNION ALL
Select  employee_id , last_name , job_id , salary
From   employees
Where  salary = 6000
;

-------------------------------------------
-- ■■■  P-36	(Union) Intersect
-------------------------------------------

--상단
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
;


--하단
Select employee_id,last_name
          ,job_id, salary
From employees
Where   salary = 6000
order by 4,3,1,2
;


--Intersect 로 처리
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
INTERSECT
Select employee_id,last_name
          ,job_id, salary
From employees
Where   salary = 6000
order by 4,3,1,2
;

-------------------------------------------
-- ■■■  P-37	(Union) Minus
-------------------------------------------

--상단
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
;


--하단
Select employee_id,last_name
          ,job_id, salary
From employees
Where   salary = 6000
;


--Minus으로 처리
Select employee_id,last_name
          ,job_id, salary
From employees
Where job_id LIKE 'IT_%'
MINUS
Select employee_id,last_name
          ,job_id, salary
From employees
Where   salary = 6000
;

-------------------------------------------
-- ■■■  P-38	※Union=Union ALL
-------------------------------------------

--Union
Select  employee_id , last_name , job_id , salary
From   employees
Where  job_id LIKE 'IT_%'
UNION
Select  employee_id , last_name , job_id , salary
From   employees
Where  salary = 6000
;


--Unin All + Distinct
Select DISTINCT employee_id  ,last_name ,job_id  ,salary
From
(   Select employee_id,last_name ,job_id, salary
    From   employees
    Where  job_id LIKE 'IT_%'
    UNION ALL
    Select employee_id,last_name ,job_id, salary
    From   employees
    Where  salary = 6000
)
;

-------------------------------------------
-- ■■■  P-40	Where절-^=, !=, <>
-------------------------------------------

--1.부정연산자 ^= 사용(인덱스 미활용)
Select DeptNO, DName, Loc
From DEPT
Where DName ^= 'SALES'
;


--2.부정연산자 != 사용
Select DeptNO, DName, Loc
From DEPT
Where DName != 'SALES'
;


--3.부정연산자 <> 사용
Select DeptNO, DName, Loc
From DEPT
Where DName <> 'SALES'
;


--a.부정연산자 ^= 의 부정(인덱스 활용)
Select DeptNO, DName, Loc
From DEPT
Where NOT DName ^= 'SALES'
;


--b.비교연산자의 부정
Select employee_id,last_name,job_id, salary
From employees
Where NOT salary >= 10000
;


--c.부정연산자 <> 의 부정
Select employee_id,last_name,job_id, salary
From employees
Where NOT salary < 10000
;

-------------------------------------------
-- ■■■  P-41	Where절-NOT Between (Union)
-------------------------------------------

-- 9000보다 작은 값과 10000보다 큰값 조회
Select employee_id,last_name , job_id, salary
From employees
Where salary NOT Between 9000 and 10000
;

=

-- 9000보다 작은 값과 10000보다 큰값 조회를 OR로 작성
Select employee_id,last_name , job_id, salary
From employees
Where salary < 9000 OR salary > 10000
;

=

-- 9000보다 작은 값과 10000보다 큰값을 Union으로 작성
Select employee_id,last_name , job_id, salary
From employees
Where salary < 9000
UNION
Select employee_id,last_name , job_id, salary
From employees
Where salary > 10000
;

x

--잘못된 쿼리 예1
Select employee_id,last_name , job_id, salary
From employees
Where salary <= 9000 and salary >= 10000
;


--잘못된 쿼리 예2
Select employee_id,last_name , job_id, salary
From employees
Where salary < 9000 and salary > 10000
;

-------------------------------------------
-- ■■■  P-42	Where절-NOT IN ( Intersect )
-------------------------------------------

-- 1.NOT IN으로 조회
Select employee_id,last_name
From  employees
Where
employee_id NOT IN ( 100, 200, 206 )
;


-- 2.부정<> 와 AND 로 조회
Select employee_id  ,last_name
From  employees
Where     employee_id <>  100
       AND employee_id <>  200
       AND employee_id <> 206
;


-- 3.<> 와 union INTERSECT로 조회
Select employee_id,last_name
From  employees
Where employee_id <>  100
INTERSECT
Select employee_id,last_name
From  employees
Where employee_id <>  200
INTERSECT
Select employee_id,last_name
From  employees
Where  employee_id <> 206
;


--a.쿼리비교, IN으로 조회
Select employee_id , last_name
From  employees
Where
Employee_id IN ( 100, 200, 206 )
;


--b.쿼리비교, = 와 AND 로 조회
Select employee_id , last_name
From  employees
Where   employee_id = 100
       OR employee_id = 200
       OR employee_id = 206
;


--c.쿼리비교, = 와 union 으로 조회
Select employee_id,last_name
From  employees
Where employee_id =  100
UNION
Select employee_id,last_name
From  employees
Where employee_id =  200
UNION
Select employee_id,last_name
From  employees
Where  employee_id = 206
;

-------------------------------------------
-- ■■■  P-43	Where절-NOT IN
-------------------------------------------

-- 괄호에 나열한 이름을 제외하고 조회
Select employee_id,last_name,salary,hire_date
From employees
Where last_name NOT IN ( 'King','Abel','Jones')
;


-- 괄호에서 나열한 날짜를 제외하고 조회
Select employee_id,last_name,salary,hire_date
From employees
Where hire_date NOT IN ( '2001/01/13','2007/02/07')
;

-------------------------------------------
-- ■■■  P-44	Where절-NOT LIKE
-------------------------------------------

-- J와1개 문자가 아닌(107건)값 조회
Select employee_id,last_name,salary
From employees
Where last_name NOT LIKE  'J_'
;


--J뒤의 4개 문자가 아닌(106건)값 조회
Select employee_id,last_name,salary
From employees
Where last_name NOT LIKE  'J____'
;


--J로 시작하는 이름이 아닌, 105건 조회1
Select employee_id,last_name,salary
From employees
Where last_name NOT LIKE  'J%'
;


--J로 시작하는 이름이 아닌, 105건 조회2
Select employee_id,last_name,salary
From employees
MINUS
Select employee_id,last_name,salary
From employees
Where last_name  LIKE  'J%'
;

-------------------------------------------
-- ■■■  P-46	연산자 우선 순위
-------------------------------------------

-- OR 앞/뒤문을 실행 결과를 Union ALL 처리.
Select last_name,job_id,salary,commission_pct
From employees
Where job_id ='AC_MGR' OR job_id='MK_REP'
AND commission_pct IS NULL
AND salary >=4000
AND salary <= 9000
;


-- 괄호안의 쿼리 실행 결과 집합에 AND조건 적용
Select last_name,job_id,salary,commission_pct
From employees
Where ( job_id ='AC_MGR' OR job_id='MK_REP' )
AND commission_pct IS NULL
AND salary >=4000
AND salary <= 9000
;

-------------------------------------------
-- ■■■  P-48	NULL 정의 및 속성 확인
-------------------------------------------

-- Null "속성" 확인. (붉은색 박스)
desc EMPLOYEES
;


-- Null "속성" 확인. (붉은색 박스)
Select Owner, Table_Name, Column_Name, Data_Type, Data_length, Nullable From  All_Tab_Columns
Where Table_Owner= 'SCOTT'
  AND Table_Name = 'EMPLOYEES'
;

-------------------------------------------
-- ■■■  P-49	NULL 생성 및 조회,식별
-------------------------------------------

-- 실습 테이블 생성 및 데이터 입력
Create Table TB_Null_Test
( id      number(4) primary key
, vlu     varchar2(10)
, ins_dt date NOT NULL
)
;
Insert into tb_null_test (id,      ins_dt) values (1,            sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (2 , ''       ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (3, null      ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (4, NULL      ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (5, (null)    ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (6, (NULL)    ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (101, ' '     ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (102, 0       ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (103, 'null'  ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (104, 'NULL'  ,sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (105, '(null)',sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (106, '(NULL)',sysdate );
Insert into tb_null_test (id, vlu, ins_dt) values (107, '널'    ,sysdate );

Commit;

-- 진짜 Null 데이터 조회
Select * From tb_null_test Where vlu is null ;

-- 가짜 Null 데이터 조회
Select * From tb_null_test Where vlu is not null ;


-------------------------------------------
-- ■■■  P-50	NULL 연산-불가능
-------------------------------------------

-- null값 count 가능 사례
Select count(*)
From tb_null_test
;

Select count(id)
From tb_null_test
;

Select count(ins_dt)
From tb_null_test
;


-- null값 있는 “컬럼” ★ count불가능 ★
Select count(vlu)
From tb_null_test
;


-- null값 "열"은 MAX, MIN 등 불가능
Select MIN(vlu) , MAX(vlu)
From tb_null_test
;

Select ascII(MIN(vlu))  /*공백 ascii 32 SP*/
       , ascii(MAX(vlu))
From tb_null_test
;


-- null값 "열"은 사칙연산 불가능
Select vlu, vlu+1
From tb_null_test
Where vlu is null
;

-------------------------------------------
-- ■■■  P-51	NULL 연산-불가능을 NVL활용, 가능하게...
-------------------------------------------

-- null값 count 가능 사례
Select count(*)
From tb_null_test
;

Select count(id)
From tb_null_test
;

Select count(ins_dt)
From tb_null_test
;


-- null값 있는 “컬럼” ★ count불가능을 가능으로 ★
Select count( NVL(vlu, '널변환') )
From tb_null_test
;


-- null값 "열"은 MAX, MIN 등 불가능을 가능으로 ★
Select MIN( NVL(vlu, '널변환') ) , MAX( NVL(vlu, '널변환') )
From tb_null_test
;

Select ascII(MIN(NVL(vlu, '널변환') ))  /*공백 ascii 32 SP*/
       , ascii(MAX(NVL(vlu, '널변환') ))
From tb_null_test
;


-- null값 "열"은 사칙연산 불가능을 가능으로 ★
Select vlu, NVL(vlu, 0 ) +1
From tb_null_test
Where vlu is null
;

Select vlu, NVL(vlu, 999 ) +1
From tb_null_test
Where vlu is null
;

Select vlu, NVL(vlu, 999 ) +1
From tb_null_test
;

-------------------------------------------
-- ■■■  P-53	rder by-ASC
-------------------------------------------

-- 숫자 컬럼에 대한 기본 오름차순 정렬
Select last_name,job_id,salary
From employees
ORDER BY salary
;


-- 숫자 컬럼에 대한 오름차순 옵션 ASC적용하여 정렬
Select last_name,job_id,salary
From employees
ORDER BY salary ASC
;

-------------------------------------------
-- ■■■  P-54	Order by-DESC
-------------------------------------------

-- 숫자 컬럼에 대한 내림차순 정렬
Select last_name,job_id,salary
From employees
ORDER BY salary DESC
;


--※ 같은 컬럼을 2개를 정렬한 사례 (단, 선행 컬럼 우선)
Select last_name,job_id,salary
From employees
ORDER BY salary DESC, salary
;

-------------------------------------------
-- ■■■  P-55	Order by-Alias, Column Number 정렬
-------------------------------------------

-- Select절의 Alias 를 Order by에 내림차순 적용
Select last_name,job_id, salary as "급여"
From employees
ORDER BY 급여 DESC
;


-- Select절의 좌측 3번째 컬럼 Order by 내림차순 적용
Select last_name ,job_id ,salary
From employees
ORDER BY 3 DESC
;

-------------------------------------------
-- ■■■  P-56	Order by-날짜, 문자 정렬
-------------------------------------------

-- 문자 속성 컬럼에 대한 Order by에 적용
Select employee_id ,last_name as 이름 ,job_id,salary
From employees
ORDER BY last_name ASC
;


-- 날짜 속성 컬럼에 Order by에 적용
Select employee_id ,last_name ,salary ,hire_date as 입사일
From employees
ORDER BY hire_date DESC
;

-------------------------------------------
-- ■■■  P-57	Order by-복수컬럼 정렬
-------------------------------------------

--Salary는 내림차순, Hire_Date는 오름차순 정렬사례
Select employee_id ,last_name ,salary ,hire_date
From employees
ORDER BY salary DESC , hire_date
;


--Select절 3번째 컬럼은 내림차순, 4번째 컬럼은 오름차순 사례
Select employee_id, last_name , salary , hire_date
From employees
ORDER BY 3 DESC , 4
;

-------------------------------------------
-- ■■■  P-58	Order by-Null 정렬
-------------------------------------------

--Null 값을 가진 숫자 속성의 컬럼에 내림차순 적용
Select last_name,job_id,salary, commission_pct
From employees
Order by  commission_pct  DESC
;


--Null 값을 가진 숫자 속성의 컬럼에 NVL함수 적용 정렬
Select      nvl(vlu,0)
From       SCOTT.TB_NULL_TEST
Order by   nvl(vlu,0) asc
;

-------------------------------------------
-- ■■■  P-59	Order by-NVL 정렬
-------------------------------------------

-- NVL 파라메터 0 사용에 따른 정렬 결과
Select employee_id, last_name,  nvl(commission_pct,0)
From employees
Order by   nvl(commission_pct,0)   DESC
;


-- NVL 파라메터 9999 사용에 따른 정렬 결과
Select employee_id, last_name,  nvl(commission_pct, 9999)
From employees
Order by   nvl(commission_pct,9999)   DESC
;

-------------------------------------------
-- ■■■  P-60	Order by-NULLS 정렬
-------------------------------------------

-- NULL First 사용 (Not Null값은 가장위에) , 데이터는 정렬규칙에 별도로 따름
Select *
From SCOTT.TB_NULL_TEST
order by vlu NULLS FIRST
;


-- NULL Last 사용 (Not Null값은 가장아래에) 데이터는 정렬규칙에 별도로 따름
Select *
From SCOTT.TB_NULL_TEST
order by vlu desc NULLS LAST
;

-------------------------------------------
-- ■■■  P-63	문자함수-SubStr
-------------------------------------------

-- 주민번호의 좌측에서 8번째위치의 1자리의 조회
Select SUBSTR('900303-1234567' , 8 , 1 )
From dual
;


-- 다양한 SubStr 사례
Select SUBSTR('900303-1234567' , -7 ,3 )
From dual
;

--123추출
Select SUBSTR('900303-1234567' , 8 ,1 )
From dual
;

-- 1추출
Select SUBSTR('900303-1234567' , 8 ,3 )
From dual
;

--123추출

-- 마이너스는 첫번째 인자에 사용, 두번째 인자는 마이너스 불가
Select SUBSTR('900303-1234567' , 10 , -3 ) From dual
;


--좌측 8번째자리부터 문자열 추출
Select SUBSTR('900303-1234567' ,8)
From dual
;


-- 다양한 SubStr 사례
Select SUBSTR('900303-1234567' , -5  )
From dual
;

--34567 추출
Select SUBSTR('900303-1234567' , 8  )
From dual
;

--1234567 추출
Select SUBSTR('900303-1234567' , 1  )
From dual
;

--900303-1234567 추출
-------------------------------------------
-- ■■■  P-64	문자함수-Replace
-------------------------------------------

--제시된 문자열에서 "J" 를 "BL" 로 변경
Select REPLACE('JACK and JUE' , 'J' , 'BL' )
From dual
;


--J를 BL로
Select 'JACK and JUE', REPLACE('JACK and JUE' , 'J' , 'BL' )
From dual
;


--대문자 A를 공백으로
Select 'JACK and JUE', REPLACE('JACK and JUE' , 'A' , ' ' )
From dual
;


--소문자 a를 공백으로
Select 'JACK and JUE', REPLACE('JACK and JUE' , 'a' , ' ' )
From dual
;


--띄어쓰기 없는 공백으로 변경 (a 삭제)
Select 'JACK and JUE',  REPLACE('JACK and JUE' , 'a' , '' )
From dual
;


--띄어쓰기 없는 공백으로 변경 (Null값으로 변경)
Select 'JACK and JUE', REPLACE('JACK and JUE' , 'JACK and JUE' , '')
From dual
;

띄어쓰기 있는 공백으로 변경 (스페이스로 변경)
Select 'JACK and JUE', REPLACE('JACK and JUE' , 'JACK and JUE' , ' ')
From dual
;

-------------------------------------------
-- ■■■  P-65	※Replace vs Update
-------------------------------------------

-- 실습 테이블 및 데이터 생성
Drop Table TB_Replace
;

Create Table TB_Replace (id   number(4), vle varchar2(16) )
;

Insert into tb_replace values ( 1, 'BLACK and BLUE' )
;

Insert into tb_replace values ( 2, 'John and Jain' )
;

Insert into tb_replace values ( 3, 'We are the World' )
;

Commit
;

Select * From tb_replace
;


-- 특정 컬럼의 값을 무조건 변경(해당 컬럼에 어떤값이든...변경)
Update TB_Replace set vle ='BLohn and BLain'
;

주) Where조건이 없으면 테이블의 모든데이터 변경됨...

-- 특정 컬럼의 내용에서 인자1의 값 비교, 인자2로 변경
Update TB_Replace set vle=REPLACE( vle,'J','BL' )
;

주) Operation이 실수로 Where절이 없이 실행해도 Replace인자 조건의 데이터만 변경되어 안정성 확보
옵션1. 변환함수를 이용해서 데이터 변경 시뮬레이션 가능
Select id, REPLACE( vle,'J','Bl' ) as "VLU"  From tb_replace
;

옵션2. CTAS명령어를 이용해서 데이터 변경 결과 테이블생성
Create Table tb_replace_Test
as
Select id, REPLACE( vle,'J','Bl' ) as "VLU"  From tb_replace
;

INSERT INTO tb_replace_Test
Select id, REPLACE( vle,'J','Bl' ) as "VLU"  From tb_replace
;

Commit
;

-------------------------------------------
-- ■■■  P-66	문자함수-TRIM
-------------------------------------------

--1 MILLER의 좌우 5개의 공백 삭제, 6자리길이표시
Select LENGTH('     MILLER     ')          as "처리전길이"
            , TRIM('     MILLER     ')         as "공백제거결과"
 , LENGTH(TRIM('     MILLER     '))  as "처리후길이"
From dual
;


--2 MILLER의 좌우 5개의 공백과 L과L사이 3개포함, 9자리길이표시
Select           LENGTH('     MIL   LER     ') as "처리전길이"
                       TRIM('     MIL   LER     ') as "공백제거결과"
          , LENGTH(TRIM('     MIL    LER     ')) as "처리후길이"
From dual
;

-- 가운데 공백은 제거 않됨....!

--2-1 가운데 공백을 지우기 위해서...
Select                   TRIM('     MIL   LER     ')
                     , Replace ('     MIL   LER     ' ,' ', '')
From dual
;


-- 첫번째 인자 "공백"을 From 절 뒤 문자열의 좌우 공백만 제거
Select TRIM( ' ' From '     MIL   LER     ' )
From dual
;


-- 첫번째 인자 "*"를 From 절 뒤 문자열에서 좌우 "*" 제거
Select TRIM( '*' From '****MIL***LER*****' )
From dual
;

-------------------------------------------
-- ■■■  P-67	문자함수-UPPER
-------------------------------------------
Select last_name, UPPER(last_name)
From employees
;

Select last_name, salary, last_name
From employees
Where UPPER(last_name)='KING'
;

Select last_name, salary, last_name
From employees
Where last_name=INITCAP ('KING')
;

-------------------------------------------
-- ■■■  P-68	문자함수-lower
-------------------------------------------

-- 문자열을 소문자 변환 쿼리
Select LOWER('Oracle Sql')
From dual
;


-- 컬럼을 소문자로 변환 쿼리
Select last_name, lower(last_name)
From employees
;

-------------------------------------------
-- ■■■  P-69	문자함수-Length
-------------------------------------------

-- 문자열의 길이 조회
Select LENGTH('Oracle')
From dual
;


-- 주어진 컬럼의 문자열 길이 조회
Select last_name, LENGTH(last_name)
From employees
;

-------------------------------------------
-- ■■■  P-70	문자함수-vSize
-------------------------------------------

-- 알파벳 길이, Bytes 조회
Select 'HongGD' , LENGTH ('HongGD') , VSize('HongGD')
From Dual
;


-- 한글 길이, Bytes 조회
Select '홍길동' , LENGTH ('홍길동') , VSize('홍길동')
From Dual
;

-------------------------------------------
-- ■■■  P-71	문자함수-LPAD
-------------------------------------------
Select LPAD('MILLER' , 10 , '*' )
From dual
;

Select LPAD('Korea' , 13 , 'Victory ' )
From dual
;

-------------------------------------------
-- ■■■  P-72	문자함수-RPAD
-------------------------------------------
Select RPAD('MILLER' , 10 , '*' )
From dual
;

Select RPAD('Korea' , 13 , 'Victory ' )
From dual
;

-------------------------------------------
-- ■■■  P-73	문자함수-INITCAP
-------------------------------------------
Select INITCAP('ORACLE SQL')
From dual
;

Select email, INITCAP(email)
From employees
;

-------------------------------------------
-- ■■■  P-74	※함수응용-Data Masking(주민번호 처리사례)
-------------------------------------------
Select SUBSTR('900303-1234567', 9 ) From dual
;

Select REPLACE( '900303-1234567', '234567', '*****' ) 주민번호
From dual
;

		or
Select REPLACE( '900303-1234567', SUBSTR('900303-1234567', 9 ) , '*****' ) 주민번호
From dual
;

-------------------------------------------
-- ■■■  P-75
-------------------------------------------
Select REPLACE( '900303-1234567', SUBSTR('900303-1234567', 9 ) , '*****' ) 주민번호
From dual
;

-------------------------------------------
-- ■■■  P-76
-------------------------------------------
Select RPAD(SUBSTR('900303-1234567',1,8),14,'*' ) as "주민번호"
From dual
;

Select SUBSTR('900303-1234567',1,8)||'******' as "주민번호"
From dual
;


-- 참고 with구문으로 변환한 케이스
with a as (  /*+ materialize*/
-- 1~10만건인경우 힌트 적용
                Select SUBSTR('900303-1234567',1,8)
                From dual
                )
Select RPAD((Select * From a) ,14,'*' ) as "주민번호"
From dual
;

-------------------------------------------
-- ■■■  P-77
-------------------------------------------
Select RPAD(SUBSTR('900303-1234567',1,8),14,'*' ) 주민번호
From dual
;

Select RPAD(SUBSTR('900303-1234567',1,8),14,'*' ) 주민번호
From dual
;

-------------------------------------------
-- ■■■  P-80	숫자함수-ROUND(절상)
-------------------------------------------

--소수점 이하 세번째 자리에서 반올림하여 2번째 자리까지 출력
Select ROUND( 456.789 , 2 )
From dual
;


--정수부 첫째 자리 반올림, 정수만 출력

--소수점 왼쪽1자리 (인자 -1의 의미)
Select ROUND( 456.789 , -1 )
From dual
;


--소수점 이하 무조건 반올림, 정수만 출력

--인자 없는 Round는 소숫점 이상 반올림
Select ROUND( 456.789  )
From dual
;

-------------------------------------------
-- ■■■  P-81	숫자함수-TRUNC(절삭)
-------------------------------------------

--소수점 이하 2번째자리 버리고 출력
Select TRUNC( 456.789 , 2 )
From dual
;


--정수부 첫째 자리까지 절삭하고, 출력
Select TRUNC( 456.789 , -1 )
From dual
;


--소수점 이하를 무조건 절삭하고, 출력
Select TRUNC( 456.789  )
From dual
;

-------------------------------------------
-- ■■■  P-82	숫자함수-CEIL(강제절상) , FLOOR(강제절삭)
-------------------------------------------

-- 강제절상 CEIL
Select CEIL(10.6), CEIL(-10.6), CEIL(10.5), CEIL(-10.5)  , CEIL(10.4), CEIL(-10.4) From  DUAL
;


-- 강제절상 CEIL VS TRUNC 비교
Select   'CEIL' as "함수"
          ,CEIL(10.6) as "10.6",CEIL(-10.6) as "-10.6",CEIL(10.5) as "10.5",CEIL(-10.5) as "-10.5",CEIL(10.4) as "10.4",CEIL(-10.4) as "-10.4"
From    dual
UNION ALL
Select   'TRUNC', TRUNC(10.6), TRUNC(-10.6) , TRUNC(10.5), TRUNC(-10.5) , TRUNC(10.4), TRUNC(-10.4)
From    dual
;


-- 강제절삭  FLOOR
Select floor(10.6), floor(-10.6), floor(10.5), floor(-10.5)  , floor(10.4), floor(-10.4) From  DUAL
;


-- 강제절삭 FLOOR VS TRUNC 비교
Select  'floor' as "함수"
         ,floor(10.6) as "10.6",floor(-10.6) as "-10.6",floor(10.5) as "10.5",floor(-10.5) as "-10.5",floor(10.4) as "10.4",floor(-10.4) as "-10.4"
From   dual
UNION ALL
Select  'TRUNC', TRUNC(10.6), TRUNC(-10.6) , TRUNC(10.5), TRUNC(-10.5) , TRUNC(10.4), TRUNC(-10.4)
From   dual
;

-------------------------------------------
-- ■■■  P-85	날짜함수-Sysdate
-------------------------------------------

-- 오늘 날짜
Select SYSDATE 오늘
From dual
;


-- 내일 날짜
Select SYSDATE 오늘, SYSDATE+1  as "내일"
From dual
;


--어제 날짜
Select SYSDATE 오늘, SYSDATE-1 as "어제"
From dual
;

-------------------------------------------
-- ■■■  P-86	날짜함수-Trunc, Round
-------------------------------------------

-- 근무 연도 구하기
Select last_name
         , hire_date
         , TRUNC((sysdate-hire_date)/365) as "년"
From employees
ORDER BY 3 desc
;


-- 근무 개월 구하기
Select last_name
         ,hire_date
         ,round (months_between(sysdate, hire_date)) "근무월수"
         ,trunc (months_between(sysdate, hire_date)) "근무월수2"
From employees
ORDER BY 3 desc
;

-------------------------------------------
-- ■■■  P-87	※ROUND vs TRUNC
-------------------------------------------
Select
    last_name,
    hire_date,
    trunc (months_between('2023-10-13', hire_date)) "근무월수",
    round (months_between('2023-10-13', hire_date)) "근무월수_1",
    trunc(trunc(months_between('2023-10-13', hire_date))/12) "근무년수",
    round(round(months_between('2023-10-13', hire_date))/12) "근무년수_1"
From employees
ORDER BY 3 desc
-------------------------------------------
-- ■■■  P-88	날짜함수-ADD_MONTHS
-------------------------------------------

-- 현재날짜의 전월, 차월 날짜 조회
Select
    sysdate                       as "현재",
    add_months(sysdate, 1)   as "다음달",
    add_months(sysdate, - 1) as "이전달"
From dual
;


--Emp~ 테이블의 hire_date에서 5개월 후 날짜
Select
    last_name,
    hire_date,
    add_months(hire_date, 5)
From employees
ORDER BY 3 desc
;

-------------------------------------------
-- ■■■  P-91	변환함수-TO_CHAR
-------------------------------------------

--숫자 1000 을 문자로 변환
Select to_char(1000) From dual
;


--숫자 0001 을 문자로 변환
Select to_char(0001) From dual
;


-- 통화 단위 표시 방법
alter session set nls_currency='￦'
;

Select last_name, salary,
   TO_CHAR(salary, '$999,999') 달러,
   TO_CHAR(salary, 'L999,999') 원화
From employees
;


--현재 시간을 날짜시간 모든 옵션 포맷 적용한 사례
Select   TO_CHAR(SYSDATE, 'YYYY/MM/DD,(AM) DY HH24:MI:SS') From dual
;


--현재 시간을 단순 날짜 포맷만 적용한 사례
Select  TO_CHAR(SYSDATE, ' YYYY "년" MM "월"  DD "일" ') AS "날짜" From dual
;


-- 포맷을 이용한 조회 (특정 월 찾기 사례이나 실제 DB에서는 성능저하 발생...)
Select last_name,hire_date, TO_CHAR(hire_date, 'MM'), salary
From employees
Where TO_CHAR(hire_date, 'MM')='09'
;


--※ 세션 환경설정

--정상
Alter session set nls_date_format='YYYY-MM-DD HH24:MI:SS'
;


--오류 발행
Alter session set nls_date_format='YYYY/MM/DD,(AM) DY HH24:MI:SS'
;

-------------------------------------------
-- ■■■  P-92	변환함수-TO_DATE(YYYY-MM-DD)
-------------------------------------------
--문자에서 날짜로 변경위한 세션 단위 포맷 선언
Alter session set nls_date_format='YYYY-MM-DD HH24:MI:SS';

--포맷일치(SQLPLUS에서 실행 케이스)
SQL> Select TO_DATE( '20170802' )  From dual;
TO_DATE('20170802')
-------------------
2017-08-02 00:00:00

--포맷불일치 문자 6자리
SQL> Select TO_DATE( '200802' ) From dual;
ORA-01861: 리터럴이 형식 문자열과 일치하지 않음

--포맷불일치 선행숫자 0이 있는 문자 6자리
SQL> Select TO_DATE( '000802' ) From dual;
ORA-01861: 리터럴이 형식 문자열과 일치하지 않음

--숫자에서 날짜로 변경위한 세션 단위 포맷 선언
alter session set nls_date_format='YYYY-MM-DD HH24:MI:SS';

--포맷일치(SQLPLUS에서 실행 케이스)
SQL> Select TO_DATE( 20170802 )  From dual;
TO_DATE(20170802)
-------------------
2017-08-02 00:00:00

--포맷불일치 숫자 6자리
SQL> Select TO_DATE( 200802 ) From dual;
ORA-01861: 리터럴이 형식 문자열과 일치하지 않음

--포맷불일치 선행숫자 0이 있는 숫자 6자리 (앞의 0은 소거됨)
SQL>  Select TO_DATE( 000802 ) From dual;
ORA-01840: 입력된 값의 길이가 날짜 형식에 비해 부족합니다
--참고 위 쿼리의 0 소거 확인 쿼리
SQL> Select TO_DATE( 802 ) From dual;
ORA-01840: 입력된 값의 길이가 날짜 형식에 비해 부족합니다

-------------------------------------------
-- ■■■  P-93	변환함수-TO_DATE(YY-MM-DD)
-------------------------------------------
--문자에서 날짜로 년2자리 월일 포맷으로 세션 단위 선언
Alter session set nls_date_format='YY-MM-DD';

--문자 8자리 포맷"불"일치(SQLPLUS에서 실행 케이스)
SQL> Select TO_DATE( '20170802' )  From dual;
TO_DATE(
--------
17-08-02

--문자 6자리 포맷일치
SQL> Select TO_DATE( '200802' ) From dual;
TO_DATE(
--------
20-08-02

--문자 6자리 포맷일치
SQL> Select TO_DATE( '000802' ) From dual;
TO_DATE(
--------
00-08-02

--숫자에서 날짜로 년2자리 월일 포맷으로 세션 단위 선언
Alter session set nls_date_format='YY-MM-DD';

--숫자 8자리 포맷"불"일치(SQLPLUS에서 실행 케이스)
SQL> Select TO_DATE( 20170802 )  From dual;
TO_DATE(
--------
17-08-02

--숫자 6자리 포맷일치
SQL> Select TO_DATE( 200802 ) From dual;
TO_DATE(
--------
20-08-02

--포맷불일치 선행숫자 0이 있는 숫자 6자리 (앞의 0은 소거됨)
SQL>  Select TO_DATE( 000802 ) From dual;
ORA-01861: 리터럴이 형식 문자열과 일치하지 않음
--참고 위 쿼리의 0 소거 확인 쿼리
SQL>  Select TO_DATE( 802 ) From dual;
ORA-01861: 리터럴이 형식 문자열과 일치하지 않음



-------------------------------------------
-- ■■■  P-94	변환함수-TO_NUMBER
-------------------------------------------

-- 입력된 문자열을 숫자로 변환 사칙연산
Select TO_NUMBER('123') + 100
From dual
;


-- 정상 사칙 연산
Select 123 + 100 From dual;			--223

--명시적 문자변환 선언한 123을 숫자로 내부 형변환
Select TO_CHAR('123') + 100 From dual;		--223

--문자열 표현한 123을 숫자로 내부 형변환
Select '123' + 100 From dual ;			 --223

--두개의 문자열로 표현한 123, 100을 내부 숫자로 형변환
Select '123' + '100' From dual; 		--223

--참고 타 DB에서의 사례
MSSQL 2000 :  '123' + '100' ? 123100
-------------------------------------------
-- ■■■  P-96	변환함수-NVL, NVL2 (숫자형으로)
-------------------------------------------

-- null값에 nvl 함수 적용사례(Vlu 컬럼은 문자, 1은 문자변환)
Select vlu, nvl(vlu,1)
From tb_null_test
;


-- 문자이므로 좌측에서부터...

-- null값에 nvl2 함수 적용사례(파라메터 모두 숫자, 1은 숫자... )
Select vlu, nvl2(vlu,1,2)
From tb_null_test
;


--숫자이므로 우측에서부터...
-------------------------------------------
-- ■■■  P-97	변환함수-NVL, NVL2 (문자형으로)
-------------------------------------------

-- nvl2 함수에 작은따옴표 적용사례(문자)
Select vlu, nvl2(vlu,'1','2')
From tb_null_test
;


-- nvl2 함수에 To_Char 적용사례(문자)
Select vlu, to_char(nvl2(vlu,1,2))
From tb_null_test
;

-------------------------------------------
-- ■■■  P-99	변환함수-DeCode함수
-------------------------------------------

-- Salary가 24000이면 20%, 17000이면 30%, 그외는 50% 적용.
Select last_name,salary,
         DECODE(salary, 24000, salary*0.2,
                              17000, salary*0.3,
                                       salary*0.5) as "보너스"
From employees
ORDER BY 2 desc
;

-------------------------------------------
-- ■■■  P-102	※DeCode함수-응용(가로출력)
-------------------------------------------

-- 입사연도 별로 사원들의 인원수를 Decode이용 가로 출력
Select
   '인원' as "입사년도" ,
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2001, 1, 0)) as "2001",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2002, 1, 0)) as "2002",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2003, 1, 0)) as "2003",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2004, 1, 0)) as "2004",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2005, 1, 0)) as "2005",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2006, 1, 0)) as "2006",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2007, 1, 0)) as "2007",
   SUM(DECODE(TO_CHAR(hire_date, 'YYYY'), 2008, 1, 0)) as "2008",
   COUNT(*) as "총계"
From  employees
;


-- 입사연도 별로 사원들의 인원수를 Gropup by 이용 세로 출력
Select to_char(hire_date,'YYYY') as "입사연도",count(*) as "인원"
From     employees
Group by to_char(hire_date,'YYYY')
UNION ALL
Select   '총계', count(*)
From     employees
Order by 1
;

-------------------------------------------
-- ■■■  P-104	CASE구문
-------------------------------------------

--Salary가 24000이면 30%, 17000이면 20%, 그외 50% 적용.
Select last_name,salary,
           CASE salary WHEN 24000 THEN salary*0.2
                           WHEN 17000 THEN salary*0.3
                                              ELSE  salary*0.5
           END 보너스
From employees
ORDER BY 2 desc
;

단점 복잡, NULL을 수동으로(NVL, 변경, ... )
장점 1.성능... Deocde보다 빠름
       2.비교연산에서 직관적이다.

--Salary가 24000이면 30%, 17000이면 20%, 그외 50% 적용.
Select last_name,salary,
         DECODE(salary,24000, salary*0.2,
                              17000, salary*0.3,
                                        salary*0.5) as "보너스"
From employees
ORDER BY 2 desc
;

장점 간략, NULL을 내부적으로 처리
단점 성능... Case보다 느림
       비교연산자 사용시 복잡함.
-------------------------------------------
-- ■■■  P-105	CASE구문-비교연산자
-------------------------------------------

-- Salary가 20000 이상이면 1000
              , 15000 이상이면 2000
              , 10000 이상이면 3000 그외는 4000 조회
Select last_name,salary,
         CASE  WHEN salary >=20000 THEN 1000
                WHEN salary >=15000 THEN 2000
                WHEN salary >=10000 THEN 3000
                ELSE 4000
         END 보너스
From employees
ORDER BY 2 desc
;

-------------------------------------------
-- ■■■  P-106	CASE구문-Between
-------------------------------------------

--Salary가 Between연산자를 이용하여 20000 과 25000이면 '상'
                                                 , 10000과 20001이면 '중'
                                                                    그외는 '하'
Select last_name,salary,
       CASE WHEN salary BETWEEN 20000 AND 25000 THEN '상'
              WHEN salary BETWEEN 10000 AND 20001 THEN '중'
                                                                       ELSE '하'
          END 등급
From employees
ORDER BY 2 desc
;

-------------------------------------------
-- ■■■  P-107	CASE구문-IN
-------------------------------------------

-- IN 연산자의 사용
Select last_name,salary,
          CASE  WHEN salary IN ( 24000, 17000 , 14000) THEN '상'
                   WHEN salary IN ( 13500, 13000)           THEN '중'
                                                                        ELSE '하'
          END 등급
From employees
ORDER BY 2 desc
;

-------------------------------------------
-- ■■■  P-110	*, Order by
-------------------------------------------

--사내 직원 정보 모두 확인
Select *
From EMPLOYEES
;


--Oracle 테이블 목록 및 구조 확인
Select *
From All_Tables
;

DESC Employees
;


-- Order by절에 Salary(8) 기준 , 급여순으로 조회.
Select *
From EMPLOYEES
order by Salary desc
;

Select *
From EMPLOYEES
order by 8 desc
;

-------------------------------------------
-- ■■■  P-111	Count, Sum
-------------------------------------------

--직원수 조회
Select count(*)
From EMPLOYEES

--전체 직원대상 월지급 총액 확인
Select sum(salary)
From EMPLOYEES
;


--직원수와 월지급 총액 동시 조회
Select count(*), sum(salary)
From EMPLOYEES
;

-------------------------------------------
-- ■■■  P-112	Where, 집계함수, 비교 & 산술연산자
-------------------------------------------

--Where절에 Dept~_ID가 90인 직원들 조회
Select first_name ,last_name ,salary ,department_id
From  EMPLOYEES
Where  department_id = 90
;


--Count, Sum 집계함수 활용 AVG 급여 조회
Select count(*) , sum(salary), sum(salary) / count(*) as avg
From EMPLOYEES
Where  department_id = 90
;

;

Select count(*) , sum(salary), avg(Salary)
From EMPLOYEES
Where  department_id = 90
;

-------------------------------------------
-- ■■■  P-113	Distinct
-------------------------------------------

--Where절에 80번 부서에 대한 Count, Sum , Avg함수 사용
Select count(*) , sum(salary) , avg(Salary)
From EMPLOYEES
Where  department_id = 80
;

;


--쿼리의 Where에 대입할 부서의 코드 종류 및 숫자 확인 필요함.
Select count(*) , sum(salary) , avg(Salary)
From EMPLOYEES
Where  department_id = ???
;

;


--Distinct 명령어로 부서번호만 조회
Select distinct DEPARTMENT_ID
From EMPLOYEES
order by 1
;


--12건 조회됨
-------------------------------------------
-- ■■■  P-114	Group by
-------------------------------------------

-- Group by 절과 Count, Sum, Avg 함수 사용

-- 오류 발생 사례2가지
Select    department_id AS "부서ID" ,
    COUNT(salary) AS "인원수" ,
    SUM(salary)     AS "소계" ,
    AVG(salary)     AS "평균"
From EMPLOYEES
;

--Ora-00937 발생
Select    department_id AS "부서ID" ,
    COUNT(salary) AS "인원수" ,
    SUM(salary)     AS "소계" ,
    AVG(salary)     AS "평균"
From EMPLOYEES
group by "부서ID"
;

-- Orac-00904 발생

-- 정상 수행
Select  department_id AS "부서ID" ,
           COUNT(salary) AS "인원수" ,
           SUM(salary)    AS "소계" ,
           AVG(salary)     AS "평균"
From    EMPLOYEES
group  by department_id
;

-------------------------------------------
-- ■■■  P-115	NVL
-------------------------------------------

-- Null 값 발생...
Select
department_id AS "부서ID" ,
COUNT(*)    AS "인원수",
SUM(salary) AS "급여“ ,
AVG(salary) AS "평균"
From EMPLOYEES
group by DEPARTMENT_ID
;


-- 소속 부서가 없는 사원 있음 ... !

--NVL함수 사용
Select
NVL(department_id, 999) AS "부서ID" ,
COUNT(*)    AS "인원수",
SUM(salary) AS "급여“ ,
AVG(salary) AS "평균"
From EMPLOYEES
group by DEPARTMENT_ID
;

-------------------------------------------
-- ■■■  P-116	Round, Order by
-------------------------------------------

-- Round함수 사용
Select
 NVL(department_id, 999) AS "부서ID" ,
COUNT(*)    AS "인원수",
SUM(salary) AS "급여" ,
ROUND(AVG(salary)) AS "평균"
From EMPLOYEES
group by DEPARTMENT_ID
;


-- Group by절에서 Order by 사용
Select
NVL(department_id, 999) AS "부서ID" ,
COUNT(*)                      AS "인원수",
SUM(salary)                   AS "급여"   ,
ROUND(AVG(salary))     AS "평균"
From EMPLOYEES
group by DEPARTMENT_ID
order by  1
;

-------------------------------------------
-- ■■■  P-117	Having-InLineView, RowNum
-------------------------------------------

-- Having절을 이용 집계 평균 7000 이상 조회
Select         department_id AS "부서ID",
	COUNT(*)    AS "인원수",
	SUM(salary) AS "급여" ,
	round(AVG(salary),1) AS "평균"
From EMPLOYEES
group by DEPARTMENT_ID
having ROUND(AVG(SALARY),1) >= 7000
order by  2 desc
;


-- 평균7000이상, InLineView와RowNum,"Order by"이용 조회
Select *
From  ( Select department_id AS "부서ID",
	  Round(AVG(salary),1) AS "평균",
	  MIN(salary) AS "최소",
	  MAX(salary) AS "최대",
	  COUNT(*)    AS "인원수",
	  SUM(salary) AS "급여"
          From EMPLOYEES
          group by DEPARTMENT_ID
          order by  2 desc
)
Where rownum < 8
;


-- 평균7000이상을  InLineView와 Where절을 이용 조회
Select *
From  ( Select department_id AS "부서ID",
	  Round(AVG(salary),1) AS "평균",
	  MIN(salary) AS "최소",
	  MAX(salary) AS "최대",
	  COUNT(*)    AS "인원수",
	  SUM(salary) AS "급여"
          From EMPLOYEES
          group by DEPARTMENT_ID
)
Where 평균 >= 7000
;

-------------------------------------------
-- ■■■  P-119	Decode 함수, Case 구문
-------------------------------------------

-- DeCode 함수로 부서명 출력
Select     department_id           AS "부서ID",
             DECODE ( department_id ,70  , 'Public Relations'
                                                ,90  , 'Executive'
                                                ,110 , 'Accounting'
   		           ,20   , 'Marketing '
                                                ,80   ,  'Sales'
                                                ,100  ,  'Finance'
                                                       ,  department_id
                     )                AS "부서명" ,
        	round(AVG(salary),1)   AS "평균",
        	MIN(salary)               AS "최소",
        	MAX(salary)              AS "최대",
        	COUNT(*)                 AS "인원수",
        	SUM(salary)              AS "급여"
From 	EMPLOYEES
group by DEPARTMENT_ID
	, DECODE ( department_id ,70  , 'Public Relations'
							,90  , 'Executive'
							,110 , 'Accounting'
				   ,20   , 'Marketing '
							,80   ,  'Sales'
							,100  ,  'Finance'
							       ,  department_id
			     )
having ROUND(AVG(SALARY),1) >= 7000
order by  2 desc
;


-- Case문으로 부서명 출력
Select      department_id          AS "부서ID",
        Case When department_id=70  then 'Public Relations'
               When department_id=90  then 'Executive'
               When department_id=110 then 'Accounting'
      When department_id=20  then 'Marketing'
      When department_id=80  then 'Sales'
      When department_id=100 then 'Finance'
                                                   Else  'N/A Dept_ID'
        End                        AS "부서명" ,
        round(AVG(salary),1)   AS "평균",
        MIN(salary)               AS "최소",
        MAX(salary)              AS "최대",
        COUNT(*)                 AS "인원수",
        SUM(salary)              AS "급여"
From EMPLOYEES
group by DEPARTMENT_ID
      , Case When department_id=70  then 'Public Relations'
               When department_id=90  then 'Executive'
               When department_id=110 then 'Accounting'
      When department_id=20  then 'Marketing'
      When department_id=80  then 'Sales'
      When department_id=100 then 'Finance'
                                                   Else  'N/A Dept_ID'
        End
having ROUND(AVG(SALARY),1) >= 7000
order by  2 desc
;

-------------------------------------------
-- ■■■  P-121	Scalar SubQuery vs INNER JOIN
-------------------------------------------

-- Scalar Sub Query문으로 부서명 조회
Select DEPARTMENT_ID         AS "부서ID",
        (Select department_name
         From departments D
         Where D.department_id = E.department_id
         )                  AS "부서명",
        COUNT(*)                 AS "인원수",
        SUM(salary)              AS "급여"   ,
        round(AVG(salary),1)   AS "평균"
From  EMPLOYEES E
group by DEPARTMENT_ID
having ROUND(AVG(SALARY),1) >= 7000
order by  2 desc
;


-- Oracle Join으로 부서명 조회
Select   E.DEPARTMENT_ID        AS "부서ID",
            D.department_name   AS "부서명",
           COUNT(*)                 AS "인원수",
           SUM(salary)              AS "급여"  ,
           round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E , DEPARTMENTS D
Where    E.department_id = D.department_id
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;

-------------------------------------------
-- ■■■  P-122	Outer Join vs Inner Join
-------------------------------------------

--Oracle INNER Join으로 부서명 조회
Select   E.DEPARTMENT_ID    AS "부서ID",
            D.department_name   AS "부서명",
            COUNT(*)                 AS "인원수",
            SUM(salary)              AS "급여"
            round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E , DEPARTMENTS D
Where    E.department_id = D.department_id
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;


-- Oracle Left Outer Join 으로 부서명 조회
Select   E.DEPARTMENT_ID    AS "부서ID",
            D.department_name   AS "부서명",
            COUNT(*)                 AS "인원수",
            SUM(salary)              AS "급여"
            round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E , DEPARTMENTS D
Where    E.department_id = D.department_id(+)
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;

-------------------------------------------
-- ■■■  P-123	Scalar SubQuery vs Outer Join
-------------------------------------------

-- Scalar Sub Query문으로 부서명 조회
Select DEPARTMENT_ID         AS "부서ID",
        (Select department_name
         From departments D
         Where D.department_id = E.department_id
         )                  AS "부서명",
        COUNT(*)                 AS "인원수",
        SUM(salary)              AS "급여"   ,
        round(AVG(salary),1)   AS "평균"
From  EMPLOYEES E
group by DEPARTMENT_ID
having ROUND(AVG(SALARY),1) >= 7000
order by  2 desc
;


-- Oracle Left Outer Join 으로 부서명 조회
Select   E.DEPARTMENT_ID    AS "부서ID",
            D.department_name   AS "부서명",
            COUNT(*)                 AS "인원수",
            SUM(salary)              AS "급여"
            round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E   , DEPARTMENTS D
Where    E.department_id = D.department_id(+)
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;

-------------------------------------------
-- ■■■  P-125	Inner Join (Oracle vs ANSI)
-------------------------------------------

-- Oracle Join으로 부서명 조회
Select   E.DEPARTMENT_ID        AS "부서ID",
            D.department_name   AS "부서명",
           COUNT(*)                 AS "인원수",
           SUM(salary)              AS "급여"  ,
           round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E , DEPARTMENTS D
Where    E.department_id = D.department_id
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;


-- ANSI Join으로 부서명 출력
Select  E.DEPARTMENT_ID        AS "부서ID",
           D.department_name   AS "부서명",
           COUNT(*)                 AS "인원수",
           SUM(salary)              AS "급여"  ,
           round(AVG(salary),1)   AS "평균"
From     EMPLOYEES E INNER JOIN DEPARTMENTS D
     ON  E.department_id = D.department_id
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;

-------------------------------------------
-- ■■■  P-126	Outer Join (Oracle vs ANSI)
-------------------------------------------

-- Oracle Left Outer Join 으로 부서명 조회
Select   E.DEPARTMENT_ID    AS "부서ID",
            D.department_name   AS "부서명",
            COUNT(*)                 AS "인원수",
            SUM(salary)              AS "급여" ,
            round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E , DEPARTMENTS D
Where    E.department_id = D.department_id(+)
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;


-- ANSI Left Outer Join 으로 부서명 조회
Select   E.DEPARTMENT_ID    AS "부서ID",
            D.department_name   AS "부서명",
            COUNT(*)                 AS "인원수",
            SUM(salary)              AS "급여" ,
            round(AVG(salary),1)   AS "평균"
From      EMPLOYEES E Left Outer Join DEPARTMENTS D
ON    E.department_id = D.department_id
group by E.DEPARTMENT_ID,  D.department_name
having   ROUND(AVG(E.SALARY),1) >= 7000
order by 2 desc
;
